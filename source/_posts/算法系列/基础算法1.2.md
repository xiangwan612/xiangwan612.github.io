---
title : 基础算法1.2
---


#### 1.快速排序     

快排属于分治算法，分治算法都有三步：

#### 主要思想：基于分治。

1.先确定分界点 /分成子问题

2.调整区间：通过划分成两个区间（难点）//递归处理子问题

｜————=<x————｜————>=x————｜

3.递归处理左右两段//子问题合并

##### 方法一（暴力做法，o（n））

新开两个数组

第一个存放小于等于x

第二个存放大于等于x

之后再将两个数组合并

##### 方法二（双指针）

```c++
#include <iostream>

using namespace std;

void quick_sort(int q[], int l, int r)//
{
    if (l >= r) return;

    int i = l - 1, j = r + 1, x = q[l + r >> 1];//x取得是l+r的平均值
    while (i < j)
    {
        do i ++ ; while (q[i] < x);//do while 先 do 后while ，如果while不成立则跳出循环。
        do j -- ; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    //递归处理子问题，将一整个长数组化成若干个小数组

    quick_sort(q, l, j);//由上面的循环先以x分成两部分，这个递归处理的是前半部分即 =< x 的数组
    quick_sort(q, j + 1, r);//同上，一直递归到处理的数组中只有两个大小的数字
}

```



```c++
#include<iostream>
using namespace std;

void quick_sort(int q[],int l,int r)
{
    if (l>=t) return ;
    
    int i = l - 1, j = r+1,x = q[l+r>>1]
        
    while(j>i)
    {
        do i++; while(q[i]<x);
        do j--;while(q[j]>x);
        if (i<j) swap(q[i],q[j]) 
    }
    quick_sort(q,l,j);
    quick_sort(q,j+1,r)
}
```



#### 待证问题

while 循环结束后，```q[l..j] <= ```

```[j+1..r] >= x```



`q[l..j] <= x`意为`q[l],q[l+1]...q[j-1],q[j]`的所有元素都<= x 
证明循环不变式：`q[l..i] <= x q[j..r] >= x`

1. ##### 初始化

循环开始之前

```i = l - 1, j = r + 1```
则```q[l..i],q[j..r]```为空，循环不变式显然成立

2. ##### 保持

假设某轮循环开始前循环不变式成立，即`q[l..i] <= x, q[j..r] >= x`

执行循环体

`do i++; while(q[i] < x);`
会使得 `q[l..i-1] <= x, q[i] >= x`

`do j--; while(q[j] > x);`
会使得` q[j+1..r] >= x, q[j] <= x`

`if(i < j) swap(q[i], q[j]);`
会使得 `q[l..i] <= x, q[j..r] >= x`
所以，i和j更新之后，下一次循环开始之前，循环不变式依然成立

注意:由于使用do-while循环,所以i和j一定会自增,使得循环会继续下去,但是如果采用while循环(i和j的初始化做出对应的变更),i和j在特殊情况下不自增的话,循环就会卡死

例如:

`while(q[i] < x) i++;
while(q[j] > x) j--;`
当`q[i]`和`q[j]`都为`x `时,` i `和` j `都不会更新,导致`while `陷入死循环

3. ##### 终止

循环结束时，`i >= j`

正常情况下，按照循环不变式，我们应该会觉得结果已经显然了

因为`i >= j，q[l..i] <= x, q[j..r] >= x`

所以按照j来划分的话，`q[l..j] <= x, q[j+1..r] >= x`是显然的

可是，最后一轮循环有点特殊，因为最后一轮循环的if语句一定不会执行

因为最后一轮循环一定满足 `i >= j`,不然不会跳出`while`循环的，所以if语句一定不执行

正确分析：

由于最后一轮的if语句一定不执行

所以，只能保证:

`q[l..i-1] <= x, q[i] >= x`

`q[j+1..r] >= x, q[j] <= x`

`i >= j`
由`q[l..i-1] <= x，i >= j(i-1 >= j-1) `和 `q[j] <= x `可以得到 `q[l..j] <= x`

又因为`q[j+1..r] >= x`
所以，`q[l..j] <= x,q[j+1..r] >= x`,问题得证

总结:只有最后一轮循环结束时，循环不变式不成立，其余的循环都是成立的
但最终要求的问题还是解决了

边界情况分析

快排属于分治算法，最怕的就是 n分成0和n，或 n分成n和0,这会造成无限划分

分析1

以j为划分时，`x`不能选`q[r]`

若以i为划分,则x不能选`q[l]`
假设` x = q[r]`

关键句子`quick_sort(q, l, j), quick_sort(q, j + 1, r);`

由于j的最小值是l,所以q[j+1..r]不会造成无限划分







#### 题目1

给定你一个长度为 n 的整数数列。

请你使用快速排序对这个数列按照从小到大进行排序。

并将排好序的数列按顺序输出。

##### 输入格式

输入共两行，第一行包含整数 n。

第二行包含 n 个整数（所有整数均在 1∼109 范围内），表示整个数列。

##### 输出格式

输出共一行，包含 n 个整数，表示排好序的数列。

##### 数据范围

1≤n≤100000

##### 输入样例：

```
5
3 1 2 4 5
```

##### 输出样例：

```
1 2 3 4 5
```





#### 答案1

```c++
#include<iostream>
using namespace std;

int n;
const int N = 10000010;
int q[N];
void quick_sort(int q[],int l,int r)
{
    if (l >= r) return ;
    int i = l-1,j = r + 1 , x = q[(l + r)/2];
    
    while(i < j)
    {
        do i ++ ;while(q[i] < x);
        do j -- ;while(q[j] > x);
        if (j > i) swap(q[i],q[j]);
    }
    quick_sort(q, l, j);
    quick_sort(q, j + 1, r);
}
int main()
{
    scanf("%d",&n);
    
    for (int i = 0;i < n;i ++ ) scanf("%d",&q[i]);//scanf会自动忽略读入时空格，
    
    quick_sort(q,0,n-1);
    
    for(int j = 0;j < n;j ++ ) printf("%d ",q[j]);//输出时要加空格，在占位符后面加就行了
    
    return 0;
}
```

### 2.归并排序

归并排序是稳定的，二快排是不稳定的

依旧以题目一为类

#### 1.先确定分界点

```c++
int mid = l + r >> 1;//位运算，速度快于直接做除法
```

#### 2.递归

```c++
merge_sort(q,l,mid),merge_sort(q,mid + 1,r);//将一个长数组分成最低含有两个数值的数组，当继续递归时，数组中仅剩余一个数字时触发    if(l>=r) return 语句函数停止，之后就由下（数组中只有两个数字的数组）往上执行归并排序；
```



#### 3.归并子数组（已有序），合二为一（使用双指针算法）

有序排列是以下代码的作用；

递归的结束的第一次排序是将两个均只含有两个数值的数组进行合并；

这里需要用到两个指针，分别指向每个数组的第一个数字，并进行比较；

小的数字加入新数组，且指针++；另外一个指针则不动，等待与另外一个数组的第二个数字比较，直至某个指针到达边界（代表某个数组已经全部加入新数组）

之后再将指针未达到边界的数组全部加到新数组里面去；

最后再将新数组给复制到原数组里面去；

```c++
int k = 0,i = l ,j = mid + 1;
    while(i <+ mid && j <= r)
    {
        if (q[i] <= q[j]) tem[k++] = q[i++];
        else tem[k++] = q[j++;]
    }
    while (i <= mid) tem[k++] = q[i++];
    while (j <= r) tem[k++] = q[j++];
    for (int i = 0,j = 0; i < r ;j++,i++) q[i] = tem[j;]
```



```c++
#include<iostream>
using namespace std;

const int N = 1000010;
int n;
int q[N],tem[N];


void merge_sort(int q[],int l,int r)
{
    if(l>=r) return ;
    
    int mid = l + r >> 1;
    merge_sort(q,l,mid),merge_sort(q,mid + 1,r);
    
    int k = 0,i = l ,j = mid + 1;
    while(i <+ mid && j <= r)
    {
        if (q[i] <= q[j]) tem[k++] = q[i++];
        else tem[k++] = q[j++;]
    }
    while (i <= mid) tem[k++] = q[i++];
    while (j <= r) tem[k++] = q[j++];
    for (int i = l  ,j = 0; i < r ;j++,i++) q[i] = tem[j;]
}


int main()
{
    scanf("%d",&n);
    for (int i = 0;i<n;i++) scanf("%d",&q[i]);
    merge_sort(q,0,n-1);
    for (int i = 0;i<n;i++) printf("%d "q[i]);
    return 0;
}

```



### 3.二分排序

二分的本质是边界问题且二分仅对有序序列产生作用。

#### 题目分析

我们先看一下另外一道类似的题目：求出有序序列中第一个大于等于x的元素的位置L，以及第一个大于x的元素的位置R。

这样元素x在序列中的存在区间就是左闭右开**[L,R)**。



假如对下标从 0 开始，有 5个元素的序列 `{1,3,3,3,6}`来说:

如果查询 3，则应当得到 L=1、R=4；

如果查询 5，则应当得到 L=R=4；

如果查询 6，则应当得到L=4、R=5；

**而如果查询 8，则应当得到 L=R=5。**

**显然，如果序列中没有 x，那么 L 和 R 也可以理解为假设序列中存在 x ，则 x 应当存在的位置。**

##### 第一问分析：

**求序列中第一个大于等于 x 的元素的位置。**
假设当前二分区间为 **[l , r]**，那么根据 mid 位置处的元素与欲查元素 x 的大小判断应当往哪个子区间继续查找：

**1.如果 A[mid]>=x**
则说明第一个大于等于 x的元素的位置，一定在 mid 处或 mid 的左侧，应往左子区间 `[l,r]` 继续查询，即令` r = mid `。

**2.如果A[mid]<x**

说明第一个大于等于x的元素的位置一定在 mid 的的右侧，应往右子区间` [mid+1,r]` 继续查询，即令` l=mid+1`。

###### 第一问代码

```c++
// A[]为递增序列，x为欲查询的数，函数返回第一个大于等于x的位置
// 二分上下界为左闭右闭的[l,r]，传入的初值为[0,n]

int lower_bound(int A[], int l, int r, int x)
{
    int mid = l + r >> 1;
    while (l < r)
    {
        if (A[mid] >= x)
        {
            r = mid;
        }
        else
        {
            l = mid + 1;
        }
    }
    return 0;
}

```

###### 代码补充与说明：

上述代码有几个需要注意的地方：

1. 循环条件为 l<r而非 l≤r (课本上的二分)

    这是由问题本身决定的，“课本上”的二分问题中，查找序列元素不存在时需要返回−1，这样当 l>r 时 [l,r]就不再是闭区间，所以该情况为判定元素不存在的标准，因此 l≤r满足时循环一直进行。但是如果要返回第一个大于等于 x 的元素的位置，就不需要判断该元素本身是否存在，因为就算它不存在，返回的也是“假设它存在，它应该在的位置”，于是当 l=r时，[l,r] 刚好能夹出唯一的位置，就是需要的结果，因此只要当 l<r 时让循环一直执行即可。

2. 由于当 l=r时 while循环停止，因此最后的返回值既可以是 l，也可以是 r。

3. 二分的所有区间应当能覆盖到所有可能返回的结果。首先，二分下界是0是显然的，但是二分上届是 n还是 n−1?

  考虑到欲查询元素有可能比序列中所有的元素都要大，此时应当返回 n (即假设它存在，它应该在的位置)，因此二分上界是 n，故二分的初始区间为 [l,r]=[0,n]。



##### 第二问分析：

同第一问

###### 第二问代码

```c++
// A[]为递增序列，x为欲查询的数，函数返回第一个大于x的位置
// 二分上下界为左闭右闭的[l,r]，传入的初值为[0,n]

int upper_bound(int A[], int l, int r, int x)
{
    int mid = l + r >> 1;
    while (l < r)
    {
        if (A[mid] > x)
        {
            r = mid;
        }
        else
        {
            l = mid + 1;
        }
    }
    return l;
}

```



**通过思考会发现，lower_bound和upper_bound都在解决这样一个问题：寻找有序序列中第一个满足某条件的元素的位置。**

**这是一个非常重要且经典的问题**

**平时能遇到的大部分二分法问题都可以归结为这个问题。所谓的“某条件”在序列中一定是从左到右先不满足，然后再满足的(否则把该条件取反即可)。**

对lower_bound来说，它寻找的就是第一个满足条件“值大于等于 x
 ”的元素的位置；对upper_bound函数来说，它寻找的是第一个满足“值大于 x
 ”的元素的位置。

另外，如果要寻找最后一个满足“条件C”的元素的位置，则可以先求第一个满足`“条件!C”`的元素的位置，然后将该位置减1即可。

分析完毕，在这道题里我们需要用到`lower_bound`和`upper_bound`减1。

###### 总代码

```c++
#include <iostream>

using namespace std;

const int N = 100010;
int a[N];

int main()
{
    int n, q;
    cin >> n >> q;

    for (int i = 0; i < n; i ++) cin >> a[i];

    while (q --)
    {
        int k;
        cin >> k;

        // 确定二分区间，这里 r 为 n
        int l = 0, r = n;
        while (l < r)
        {
            int mid = l + r >> 1;
            // a[mid] 大于等于 k 说明第一个大于等于 k 的元素一定在 mid 处或 mid 左边
            // 右边界变小，更加关注左半区间
            if (a[mid] >= k) r = mid;

            //a[mid] 小于 k 说明第一个大于等于 k 的元素一定在 mid 右边(不包含 mid)
            // 左边界变大，更加关注右半区间
            else l = mid + 1;
        }

        // 二分一定有答案，但要检查答案是否正确
        // 若序列中没有等于 k 的元素，查找出的是第一个大于 k 的元素的下标
        if (a[l] != k) cout << "-1 -1" << endl;
        else
        {
            cout << l << ' ';
            int l = 0, r = n;
            while (l < r)
            {
                int mid = l + r >> 1;
                // 不同点在这里的 check 函数
                // 这一部分要寻找的是元素 k 的终止位置
                // 我们可以理解为求第一个满足大于 k 的位置，再将结果减 1 ，即是最后一个大于等于 k 的位置
                if (a[mid] > k) r = mid;
                else l = mid + 1;
            }
            // 这也是我们的 r 要开到 n 的原因，假设我们的目标 k 是 a[n-1]
            // 那么第一个大于 k 的下标将达到 n ，如果二分区间到不了这，将导致答案错误
            cout << l - 1 << endl;
        }
    }
}

```

















